'.source.rust':
  # Attributes
  'allow':
    prefix: 'allow'
    body: '#[allow(${1:lint})]'
  'allow!':
    prefix: 'allow!'
    body: '#![allow(${1:lint})]'
  'cfg':
    prefix: 'cfg'
    body: '#[cfg($1)]'
  'deny':
    prefix: 'deny'
    body: '#[deny(${1:lint})]'
  'deny!':
    prefix: 'deny!'
    body: '#![deny(${1:lint})]'
  'derive':
    prefix: 'derive'
    body: '#[derive(${1:Trait})]'
  'feature':
    prefix: 'feature'
    body: '#![feature(${1:feature})]'
  'no_std':
    prefix: 'no_std'
    body: '#![no_std]'
  'no_main':
    prefix: 'no_main'
    body: '#![no_main]'
  'warn':
    prefix: 'warn'
    body: '#[warn(${1:lint})]'
  'warn!':
    prefix: 'warn!'
    body: '#![warn(${1:lint})]'
  'macroexp':
    prefix: 'macroexp'
    body: '#[macro_export]'
  'repr':
    prefix: 'repr'
    body: '#[repr($1)]'

  # Definitions
  'enum':
    prefix: 'enum'
    body: '''
      enum ${1:TypeName} {
      \t$2
      }
    '''
  'impl':
    prefix: 'impl'
    body: '''
      impl ${1:TypeName} {
      \t$2
      }
    '''
  'implf':
    prefix: 'implf'
    body: '''
      impl ${1:Trait} for ${2:TypeName} {
      \t$2
      }
    '''
  'macro':
    prefix: 'macro'
    body: '''
      macro_rules! ${1:macro_name} {
      \t($2) => ($3);
      }
    '''
  'struct':
    prefix: 'struct'
    body: '''
      struct ${1:TypeName} {
      \t$2
      }
    '''
  'trait':
    prefix: 'trait'
    body: '''
      trait ${1:TraitName} {
      \t$2
      }
    '''
  'union':
    prefix: 'union'
    body: '''
      union ${1:TypeName} {
      \t$2
      }
    '''

  # Bindings
  'fn':
    prefix: 'fn'
    body: '''
      fn ${1:function_name}($2) {
      \t${3:unimplemented!()}
      }
    '''
  'fnr':
    prefix: 'fnr'
    body: '''
      fn ${1:function_name}($2) -> ${3:TypeName} {
      \t${4:unimplemented!()}
      }
    '''
  'if-let':
    prefix: 'if-let'
    body: '''
      if let ${1:pattern} = ${2:expr} {
      \t$3
      }
    '''
  'let':
    prefix: 'let'
    body: 'let ${1:variable} = ${2:value};'
  'static':
    prefix: 'static'
    body: 'static ${1:CONSTANT}: ${2:TypeName} = ${3:value};'
  'type':
    prefix: 'type'
    body: 'type ${1:TypeName} = ${2:TypeName};'
  'while-let':
    prefix: 'while-let'
    body: '''
      while let ${1:pattern} = ${2:expr} {
      \t$3
      }
    '''

  # Control flow
  'for':
    prefix: 'for'
    body: '''
      for ${1:variable} in ${2:iterator} {
      \t$3
      }
    '''
  'if':
    prefix: 'if'
    body: '''
      if ${1:expression} {
      \t$2
      }
    '''
  'if-else':
    prefix: 'if-else'
    body: '''
      if ${1:expression} {
      \t$2
      } else {
      \t$3
      }
    '''
  'if-elseif-else':
    prefix: 'if-elseif-else'
    body: '''
      if ${1:expression} {
      \t$2
      } esle if ${3:expression} {
      \t$4
      } else {
      \t$5
      }
    '''
  'loop':
    prefix: 'loop'
    body: '''
      loop {
      \t$1
      }
    '''
  'while':
    prefix: 'while'
    body: '''
      while ${1:expression} {
      \t$2
      }
    '''
  'match':
    prefix: 'match'
    body: '''
      match ${1:expression} {
      \t$2
      }
    '''

  # Unit testing
  'test':
    prefix: 'test'
    body: '''
      #[test]
      fn ${1:test_name}() {
      \t${2:unimplemented!()}
      }
    '''
  'testmod':
    prefix: 'testmod'
    body: '''
      #[cfg(test)]
      mod tests {
      \tuse super::*;

      \t#[test]
      \tfn ${1:test_name}() {
      \t\t${2:unimplemented!()}
      \t}
      }
    '''

  # Macros
  'asm':
    prefix: 'asm'
    body: '''
      asm!(${1:assemblyTemplate}
      : ${2:outputOperands}
      : ${3:inputOperands}
      : ${4:clobbers}
      : ${5:options}
      );
    '''
  'assert':
    prefix: 'assert'
    body: 'assert!($1);'
  'assert_eq':
    prefix: 'assert_eq'
    body: 'assert_eq!($1, $2);'
  'assert_ne':
    prefix: 'assert_ne'
    body: 'assert_ne!($1, $2);'
  'eprint':
    prefix: 'eprint'
    body: 'eprint!("${1:{${2::?}\\}}", ${3});'
  'eprintln':
    prefix: 'eprintln'
    body: 'eprintln!("${1:{${2::?}\\}}", ${3});'
  'print':
    prefix: 'print'
    body: 'print!("${1:{${2::?}\\}}", ${3});'
  'println':
    prefix: 'println'
    body: 'println!("${1:{${2::?}\\}}", ${3});'
  'stringify':
    prefix: 'stringify'
    body: 'stringify!($1);'
  'write':
    prefix: 'write'
    body: 'write!(${1:out}, "${2:{${3::?}\\}}", ${4});'
  'writeln':
    prefix: 'writeln'
    body: 'writeln!(${1:out}, "${2:{${3::?}\\}}", ${4});'

  # Misc
  'main':
    prefix: 'main'
    body: '''
      fn main() {
      \t${1:unimplemented!()}
      }
    '''

  'mainres':
    prefix: 'mainres'
    body: '''
      fn main() -> Result<(), Box<dyn std::error::Error>> {
      \t${1:unimplemented!()}
      }
    '''

  'start':
    prefix: 'start'
    body: '''
      #![no_main]
      fn _start() -> ! {
      \t${1:unimplemented!()}
      }
    '''
